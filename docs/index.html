<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>index</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">



<section id="al-marj-flood-impact-comprehensive-evaluation-system" class="level1 page-columns page-full">
<h1>Al Marj Flood Impact Comprehensive Evaluation System</h1>
<section id="project-summary" class="level2">
<h2 class="anchored" data-anchor-id="project-summary">Project Summary</h2>
<p>This project crafts an application within Google Earth Engine to evaluate the repercussions of the substantial flood event that transpired in Al Marj, Libya, during September 2023. The application integrates satellite imagery for flood mapping, land cover data for analyzing affected land cover types, and random forest classification to detect affected buildings. Additionally, it utilizes population grid data to estimate the number of people affected by the flood. The results provide a comprehensive assessment of the flood extent, affected land cover areas, impacted buildings, and the affected population, which is crucial for informing disaster response and management efforts.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Study_Area.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Study Area</figcaption>
</figure>
</div>
<section id="problem-statement" class="level3">
<h3 class="anchored" data-anchor-id="problem-statement">Problem Statement</h3>
<p>In September 2023, severe flooding in Al Marj, Libya, caused significant damage to infrastructure and displaced numerous people. Rapid and accurate assessment of the flood’s impact is essential for effective disaster response and management. This application aims to address the following key research questions:</p>
<ol type="1">
<li><p>What is the total area affected by the flooding?</p></li>
<li><p>What is the extent of damage affected by the flooding to different land cover types, particularly agricultural land and built-up areas? How the the flooding affact the area of Buildings?</p></li>
<li><p>How many people are estimated to be affected by the flooding?</p></li>
</ol>
</section>
<section id="end-user" class="level3">
<h3 class="anchored" data-anchor-id="end-user">End User</h3>
<p><strong>Government departments and international organizations:</strong></p>
<p>By visualizing flooded areas, affected buildings, and population data, our project enables these departments to quickly and accurately assess the disaster situation. This facilitates effective rescue and reconstruction planning, as well as optimization of future urban development, land use, and drainage systems.</p>
<p><strong>Affected communities and the public:</strong></p>
<p>The spatial distribution map of the flooded area generated by the project can help the affected communities and the public intuitively understand the scope and severity of the flood impact, and take timely countermeasures.</p>
</section>
<section id="data" class="level3">
<h3 class="anchored" data-anchor-id="data">Data</h3>
<p><strong>Sentinel-1 Satellite Image:</strong> <a href="https://developers.google.com/earth-engine/datasets/catalog/COPERNICUS_S1_GRD">Sentinel-1</a> collects C-band synthetic aperture radar (SAR) imagery at a variety of polarizations and resolutions. We use it to detect flood coverage.</p>
<p><strong>Sentinel-2 Satellite Image:</strong> <a href="https://developers.google.com/earth-engine/datasets/catalog/sentinel-2">Sentinel-2</a> is a wide-swath, high-resolution, multispectral imaging mission with a global 5-day revisit frequency.</p>
<p><strong>Surface Water:</strong><a href="https://developers.google.com/earth-engine/datasets/catalog/JRC_GSW1_4_Metadata">JRC Global Surface Water Metadata</a> contains maps of the location and temporal distribution of surface water. Year-round water is filtered using the JRC Global Water Seasonal Data layer.</p>
<p><strong>DEM:</strong><a href="https://developers.google.com/earth-engine/datasets/catalog/WWF_HydroSHEDS_03VFDEM#description">WWF HydroSHEDS Void-Filled DEM</a> excludes areas with gradients greater than 5%.</p>
<p><strong>Land Classification:</strong> <a href="https://developers.google.com/earth-engine/datasets/catalog/ESA_WorldCover_v200#description">ESA WorldCover 10m v200</a> ESA WorldCover10m contains 11 land cover classes based on Sentinel-1 and Sentinel-2 data.</p>
<p><strong>Population:</strong> <a href="https://developers.google.com/earth-engine/datasets/catalog/JRC_GHSL_P2023A_GHS_POP">GHSL: Global population surfaces 1975-2030</a> contains the spatial distribution of residential population, expressed as the absolute number of inhabitants of the cell.</p>
</section>
<section id="methodology" class="level3">
<h3 class="anchored" data-anchor-id="methodology">Methodology</h3>
<p><strong>Flood extent mapping:</strong></p>
<p>The areas affected by the flood are identified by calculating the difference between pre-flood and post-flood images.</p>
<p><strong>Land cover impact assessment:</strong> By overlaying the flood extent layer with the land cover, the affected built-up areas and croplands are assessed.</p>
<p><strong>Building damage assessment:</strong></p>
<p>The random forest classification algorithm is applied to the Sentinel-2 multispectral imagery to extract buildings within the built-up areas. The accuracy is evaluated using a confusion matrix.</p>
<p><strong>Population impact assessment:</strong></p>
<p>By overlaying the flood extent map with the population grid, the application calculates the total number of individuals residing within the inundated areas.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/procedure.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Work Flow</figcaption>
</figure>
</div>
</section>
<section id="interface" class="level3">
<h3 class="anchored" data-anchor-id="interface">Interface</h3>
<p>Users will be able to interact with the perform:</p>
<ol type="1">
<li><p>Draw an Area of Interest (AOI): Users can draw a polygon on the map to define a specific area they want to analyze.</p></li>
<li><p>Obtain information: The application will process the data within the AOI and display the key indicators in the results panel, including Total Area, Flood Extent Areas, Damaged Built-Up Areas, Damaged Cropland Areas, Estimated Affected Population.</p></li>
<li><p>Visualization: The map will display visual overlays within the AOI that include Affected Built-Up, Affected Cropland, A ffected Building Footprints, and Flood Areas. This setup clearly identifies flood-impacted regions.</p></li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Interface.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Interface</figcaption>
</figure>
</div>
</section>
</section>
<section id="the-application" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="the-application">The Application</h2>
<p>This is our Earth Engine application.</p>
<div class="column-page">
<iframe src="https://hanmengyuan826.users.earthengine.app/view/flooddamage" width="100%" height="700px">
</iframe>
</div>
</section>
<section id="how-it-works" class="level2">
<h2 class="anchored" data-anchor-id="how-it-works">How it Works</h2>
<section id="analysis" class="level3">
<h3 class="anchored" data-anchor-id="analysis">Analysis</h3>
<p><strong>1. Flood Area Analysis</strong></p>
<p>1.1 Data Preprocessing</p>
<p>We imported the administrative boundary data of Al Marj region and filtered the area of interest (AOI).</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Import the administrative boundary of Libya and filter the target region (Al Marj) as the area of interest (AOI) var admin = ee.FeatureCollection("projects/ee-hanmengyuan9/assets/libya"); var geometry = admin.filter(ee.Filter.eq('shapeName', 'Al Marj')); Map.addLayer(geometry, {color: 'grey'}, 'Al Marj');</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>And we selected the Sentinel-1 SAR image collection, set parameters and filter images for the flood periods.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Define the time periods before and after the flood event var before_start = '2023-09-01'; var before_end = '2023-09-15'; var after_start = '2023-09-23'; var after_end = '2023-09-30';  // Set sensor parameters for the satellite data collection var polarization = ("VH", "VV"); var pass_direction = "DESCENDING"; var difference_threshold = 1.00;  // Defining the area of interest based on the filtered geometry var aoi = geometry;  // Filtering the satellite image collection based on the specified parameters var collection = ee.ImageCollection('COPERNICUS/S1_GRD')   .filter(ee.Filter.eq('instrumentMode', 'IW'))   .filter(ee.Filter.listContains('transmitterReceiverPolarisation', polarization))   .filter(ee.Filter.eq('orbitProperties_pass', pass_direction))   .filter(ee.Filter.eq('resolution_meters', 10))   .filterBounds(aoi)   .select(polarization);    // Filter the image collection to obtain images from before and after the flood var before_collection = collection.filterDate(before_start, before_end); var after_collection = collection.filterDate(after_start, after_end);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Then, we mosaicked, clipped, and applied speckle noise reduction to the filtered before and after image collections to optimize data quality.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Create a mosaic of selected tiles and clip to study area var before = before_collection.mosaic().clip(aoi); var after = after_collection.mosaic().clip(aoi);  // Apply reduce the radar speckle by smoothing   var smoothing_radius = 50; var before_filtered = before.focal_mean(smoothing_radius, 'circle', 'meters'); var after_filtered = after.focal_mean(smoothing_radius, 'circle', 'meters');</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>1.2 Flood Extent Extraction</p>
<p>We extracted the flood extent using threshold segmentation and further optimize the flood extent using surface water data, connectivity analysis, and terrain filtering.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Calculate the difference between the before and after images var difference = after_filtered.divide(before_filtered);  // Apply the predefined difference-threshold and create the flood extent mask  var threshold = difference_threshold; var difference_binary = difference.gt(threshold);  // Refine flood result using additional datasets              // Include JRC layer on surface water seasonality to mask flood pixels from areas       // of "permanent" water (where there is water &gt; 10 months of the year)       var swater = ee.Image('JRC/GSW1_0/GlobalSurfaceWater').select('seasonality');       var swater_mask = swater.gte(10).updateMask(swater.gte(10));              // Flooded layer where perennial water bodies (water &gt; 10 mo/yr) is assigned a 0 value       var flooded_mask = difference_binary.where(swater_mask,0);       // final flooded area without pixels in perennial waterbodies       var flooded = flooded_mask.updateMask(flooded_mask);              // Compute connectivity of pixels to eliminate those connected to 8 or fewer neighbours       // This operation reduces noise of the flood extent product        var connections = flooded.connectedPixelCount();           var flooded = flooded.updateMask(connections.gte(8));              // Mask out areas with more than 5 percent slope using a Digital Elevation Model        var DEM = ee.Image('WWF/HydroSHEDS/03VFDEM');       var terrain = ee.Algorithms.Terrain(DEM);       var slope = terrain.select('slope');       var flooded = flooded.updateMask(slope.lt(5));</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>1.3 Flood Area Calculation</p>
<p>We calculated the flood inundation area based on pixel area and regional statistics.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Calculate flood extent area // Create a raster layer containing the area information of each pixel  var flood_pixelarea = flooded.select(polarization)   .multiply(ee.Image.pixelArea());  // Sum the areas of flooded pixels // default is set to 'bestEffort: true' in order to reduce computation time, for a more  // accurate result set bestEffort to false and increase 'maxPixels'.  var flood_stats = flood_pixelarea.reduceRegion({   reducer: ee.Reducer.sum(),                 geometry: aoi,   scale: 10, // native resolution    //maxPixels: 1e9,   bestEffort: true   });  // Convert the flood extent to hectares (area calculations are originally given in meters)   var flood_area_ha = flood_stats   .getNumber(polarization)   .divide(10000)   .round();</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Flooded_Areas.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Flooded Areas</figcaption>
</figure>
</div>
<p><strong>2. Identify buildings affected by flooding</strong></p>
<p>2.1 Data preprocessing</p>
<p>The obtained Sentinel-2 image is filtered, processed, cropped, and a preliminary image is generated. A mask is then applied to the data based on NDWI and NDVI thresholds (0.3 and 0.2, respectively) to filter out non-water and low vegetation cover areas.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Define an array of band names for Sentinel-2 imagery var bands = ['B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B8A', 'B11', 'B12'];  // Create an ImageCollection of Sentinel-2 surface reflectance images var sentinel2 = ee.ImageCollection('COPERNICUS/S2_SR')   .filter(ee.Filter.date(before_start, after_end)) // Filter images by date range   .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10)) // Filter images with less than 10% cloud cover   .mean() // Compute the mean value of each pixel across the filtered images   .select(bands) // Select the specified bands   .clip(geometry); // Clip the resulting image to the specified geometry  // Define visualization parameters for RGB composite var s_rgb = {   min: 0.0, // Minimum value for stretching the image   max: 3000, // Maximum value for stretching the image   bands: ['B4', 'B3', 'B2'], // Red, Green, Blue bands for the composite   opacity: 1 // Opacity of the layer };  // Calculate NDVI (Normalized Difference Vegetation Index) var ndvi = sentinel2.normalizedDifference(['B8', 'B4']).select(['nd'], ['ndvi']);  // Calculate NDWI (Normalized Difference Water Index) var ndwi = sentinel2.normalizedDifference(['B3', 'B8']).select(['nd'], ['ndwi']);  // Create a masked image based on NDWI and NDVI thresholds and add NDVI band var image = sentinel2   .updateMask(ndwi.lt(0.3)) // Mask pixels with NDWI less than 0.3   .updateMask(ndvi.lt(0.2)) // Mask pixels with NDVI less than 0.2   .addBands(ndvi); // Add the NDVI band to the image</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>2.2 RF analysis</p>
<p>To improve the accuracy of the training building model, we will classify and identify different features (such as buildings, farmland, deserts, etc.) together by Random Forest.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> building_points <span class="op">=</span> ee<span class="op">.</span><span class="at">FeatureCollection</span><span class="op">.</span><span class="fu">randomPoints</span>(buildings2<span class="op">,</span> <span class="dv">3000</span>)<span class="op">.</span><span class="fu">map</span>(<span class="kw">function</span>(i) {   <span class="cf">return</span> i<span class="op">.</span><span class="fu">set</span>({<span class="st">'class'</span><span class="op">:</span> <span class="dv">0</span>})<span class="op">;</span> })<span class="op">;</span> <span class="kw">var</span> farm_points <span class="op">=</span> ee<span class="op">.</span><span class="at">FeatureCollection</span><span class="op">.</span><span class="fu">randomPoints</span>(farmland<span class="op">,</span> <span class="dv">3000</span>)<span class="op">.</span><span class="fu">map</span>(<span class="kw">function</span>(i) {   <span class="cf">return</span> i<span class="op">.</span><span class="fu">set</span>({<span class="st">'class'</span><span class="op">:</span> <span class="dv">1</span>})<span class="op">;</span> })<span class="op">;</span> <span class="kw">var</span> desert_points <span class="op">=</span> ee<span class="op">.</span><span class="at">FeatureCollection</span><span class="op">.</span><span class="fu">randomPoints</span>(desert<span class="op">,</span> <span class="dv">3000</span>)<span class="op">.</span><span class="fu">map</span>(<span class="kw">function</span>(i) {   <span class="cf">return</span> i<span class="op">.</span><span class="fu">set</span>({<span class="st">'class'</span><span class="op">:</span> <span class="dv">2</span>})<span class="op">;</span> })<span class="op">;</span> <span class="kw">var</span> water_points <span class="op">=</span> ee<span class="op">.</span><span class="at">FeatureCollection</span><span class="op">.</span><span class="fu">randomPoints</span>(water<span class="op">,</span> <span class="dv">3000</span>)<span class="op">.</span><span class="fu">map</span>(<span class="kw">function</span>(i) {   <span class="cf">return</span> i<span class="op">.</span><span class="fu">set</span>({<span class="st">'class'</span><span class="op">:</span> <span class="dv">3</span>})<span class="op">;</span> })<span class="op">;</span> <span class="kw">var</span> road_points <span class="op">=</span> ee<span class="op">.</span><span class="at">FeatureCollection</span><span class="op">.</span><span class="fu">randomPoints</span>(road<span class="op">,</span> <span class="dv">3000</span>)<span class="op">.</span><span class="fu">map</span>(<span class="kw">function</span>(i) {   <span class="cf">return</span> i<span class="op">.</span><span class="fu">set</span>({<span class="st">'class'</span><span class="op">:</span> <span class="dv">4</span>})<span class="op">;</span> })<span class="op">;</span> <span class="kw">var</span> parking_points <span class="op">=</span> ee<span class="op">.</span><span class="at">FeatureCollection</span><span class="op">.</span><span class="fu">randomPoints</span>(parking<span class="op">,</span> <span class="dv">3000</span>)<span class="op">.</span><span class="fu">map</span>(<span class="kw">function</span>(i) {   <span class="cf">return</span> i<span class="op">.</span><span class="fu">set</span>({<span class="st">'class'</span><span class="op">:</span> <span class="dv">5</span>})<span class="op">;</span> })<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Combine the random points and split them into training and validation sets and we used the split ratio equal to 0.7.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Combine the random points for each land cover class into a single FeatureCollection var sample = ee.FeatureCollection([   building_points,   farm_points,   desert_points,   water_points,   road_points,   parking_points ]) .flatten()  // Flatten the FeatureCollection .randomColumn(); // Add a random column to the FeatureCollection for splitting  // Define the split ratio for training and validation samples var split = 0.7;  // Create training sample by filtering the sample FeatureCollection where the random column is less than the split ratio var training_sample = sample.filter(ee.Filter.lt('random', split));  // Create validation sample by filtering the sample FeatureCollection where the random column is greater than or equal to the split ratio var validation_sample = sample.filter(ee.Filter.gte('random', split));</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Sample the image using the training and validation points and Train a Random Forest classifier using the training samples.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Sample the image using the training sample var training = image.sampleRegions({   collection: training_sample,   properties: ['class'],   scale: 10, });  // Sample the image using the validation sample var validation = image.sampleRegions({   collection: validation_sample,   properties: ['class'],   scale: 10 });  // Train a Random Forest classifier using the training samples var model = ee.Classifier.smileRandomForest(400)   .train(training, 'class');</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Classify the image using the trained model and extract the building class from the prediction.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Classify the image using the trained model var prediction = image.classify(model);  // Extract the building class from the prediction by masking pixels that are not classified as buildings (class 0) var building_prediction = prediction.updateMask(prediction.eq(0));</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>3. Calculate the built-up areas, croplands, buildings footprint and population after the disaster</strong></p>
<p>Import ESA WorldCover into the map and extract cropland and built-up land from it. By intersecting the Build-up land with the identified buildings, we will focus on the disaster situation of the buildings in the built-up area. Finally, the flood data mask was used to obtain the cropland, built-up areas, building spatial distribution and population after the disaster.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Use the ESA WorldCover 10m v200 dataset var dataset = ee.ImageCollection('ESA/WorldCover/v200')   .first() // Take the first Image   .select('Map') // Select the 'Map' band   .clip(aoi);  // Get the projection information of ESA WorldCover var worldCoverProjection = dataset.projection();  // Reproject the flood layer to the scale of ESA WorldCover var flooded_res = flooded.reproject({   crs: worldCoverProjection });  // Add the ESA WorldCover layer to the map var worldCoverVis = {   min: 10,   max: 100,   palette: [     '#006400', '#ffbb22', '#ffff4c', '#f096ff', '#fa0000',     '#b4b4b4', '#f0f0f0', '#0064c8', '#0096a0', '#00cf75',     '#fae6a0'   ] }; Map.addLayer(dataset, worldCoverVis, 'ESA WorldCover');  // Select cropland category (class code 40 corresponds to cropland) var cropland = dataset.eq(40); // Calculate affected cropland area var croplandAffected = flooded_res.updateMask(cropland);  // Select built-up category (class code 50) var buildland = dataset.eq(50); var class_prediction = prediction.updateMask(prediction.eq(0));  // ---------- Construct Building Spatial Distribution ----------- // Mask classification results using built-up area masks after resampling var maskedClassPrediction = prediction.updateMask(builtUp);  // Convert masked classification results to 1-bit depth black and white images var maskedClassPredictionBinary = maskedClassPrediction.multiply(255).toByte();  // Add converted classification results to the map Map.addLayer(maskedClassPredictionBinary, {min: 0, max: 1}, 'Built-up Area Prediction (Binary)');  // ---------- Load population data ----------- // Load population data from GHSL var population = ee.Image('JRC/GHSL/P2023A/GHS_POP/2020')   .clip(aoi); // Get GHSL projection var GHSLprojection = population.projection(); // Reproject flood layer to GHSL scale var flooded_res1 = flooded.reproject({   crs: GHSLprojection });  // Calculate flood-affected population by applying the flood and population masks var floodedPopulation = population   .updateMask(flooded_res1)   .updateMask(population);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Construct the function about calculating the area of affected croplands, built-up areas and population.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">calculateFloodImpactStats</span>(Affected_Cropland<span class="op">,</span> Affected_Builtup<span class="op">,</span> Flooded_Population<span class="op">,</span> Flooded_Areas<span class="op">,</span>  polarization<span class="op">,</span> aoi) {   <span class="co">// Calculate the area of each affected cropland pixel   var affectedCroplandArea = Affected_Cropland.multiply(ee.Image.pixelArea());    // Calculate the sum of the affected cropland area   var croplandStats = affectedCroplandArea.reduceRegion({     reducer: ee.Reducer.sum(),     geometry: aoi,     scale: 10, // Use the original resolution of the WorldCover dataset (10m)     maxPixels: 1e9   });    // Convert the affected cropland area from square meters to hectares   var croplandAreaHectares = ee.Number(croplandStats.get('b1')).divide(10000).round();    // Calculate the area of each affected built-up land pixel   var affectedBuildlandArea = Affected_Builtup.multiply(ee.Image.pixelArea());    // Calculate the sum of the affected built-up land area   var buildlandStats = affectedBuildlandArea.reduceRegion({     reducer: ee.Reducer.sum(),     geometry: aoi,     scale: 10, // Use the original resolution of the WorldCover dataset (10m)     maxPixels: 1e9   });    // Convert the affected built-up land area from square meters to hectares   var buildlandAreaHectares = ee.Number(buildlandStats.get('b1')).divide(10000).round();    // Calculate the number of affected population   var populationStats = Flooded_Population.reduceRegion({     reducer: ee.Reducer.sum(),     geometry: aoi,     scale: 100,     maxPixels: 1e9   });    // Get the affected population count   var affectedPopulation = ee.Number(populationStats.get('b1')).round();    // Calculate the area of the flooded regions   var flood_pixelarea = Flooded_Areas.multiply(ee.Image.pixelArea());    // Calculate the sum of the flooded area   var flood_stats = flood_pixelarea.reduceRegion({     reducer: ee.Reducer.sum(),     geometry: aoi,     scale: 10,     bestEffort: true   });    // Convert the flooded area from square meters to hectares   var flood_area_ha = ee.Number(flood_stats.get('b1')).divide(10000).round();    // Calculate the total area of the selected region   var totalArea = ee.Image.pixelArea().reduceRegion({     reducer: ee.Reducer.sum(),     geometry: aoi,     scale: 10,     maxPixels: 1e13   });    // Convert the total area from square meters to hectares   var totalAreaHectares = ee.Number(totalArea.get('area')).divide(10000).round();    // Return an object containing all the calculated results   return {     croplandAreaHectares: croplandAreaHectares,     buildlandAreaHectares: buildlandAreaHectares,     affectedPopulation: affectedPopulation,     floodAreaHectares: flood_area_ha,     totalAreaHectares: totalAreaHectares   }; }</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Affected Build-up Areas <img src="images/Affected Build-up Areas.jpg" class="img-fluid" alt="Affected Build-up Areas"></p>
<p>Affected Cropland Areas <img src="images/Affected Cropland Areas.jpg" class="img-fluid" alt="Affected Cropland Areas"></p>
<p>Affected Building Distribution of One City <img src="images/Affected_Buildings_Footprints2.jpg" class="img-fluid" alt="Affected Building Distribution of One City"></p>
</section>
<section id="user-interface" class="level3">
<h3 class="anchored" data-anchor-id="user-interface">User Interface</h3>
<ol type="1">
<li>Create a map instance and Set the center point and zoom level of the map. Focus on the country that needs to be analysed.</li>
</ol>
<div class="sourceCode" id="cb13"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="bu">Map</span><span class="op">.</span><span class="fu">setCenter</span>(<span class="fl">21.0842</span><span class="op">,</span> <span class="fl">31.9395</span><span class="op">,</span> <span class="dv">10</span>)<span class="op">;</span>  <span class="kw">var</span> admin <span class="op">=</span> ee<span class="op">.</span><span class="fu">FeatureCollection</span>(<span class="st">"projects/ee-hanmengyuan9/assets/libya"</span>)<span class="op">;</span> <span class="kw">var</span> geometry<span class="op">=</span>admin<span class="op">.</span><span class="fu">filter</span>(ee<span class="op">.</span><span class="at">Filter</span><span class="op">.</span><span class="fu">eq</span>(<span class="st">'shapeName'</span><span class="op">,</span><span class="st">'Al Marj'</span>))<span class="op">;</span>  <span class="co">// Add the filtered feature collection to the map Map.addLayer(geometry,{color:'grey'},'Al Marj');  // Add Google Satellite imagery to the map Map.setOptions('SATELLITE');  // Set the map center to the area of interest Map.centerObject(geometry, 8);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="2" type="1">
<li>User interface layout</li>
</ol>
<p>The UI design is structured to facilitate the interpretation and analysis of data regarding flooded regions. The layout can be divided into distinct zones: the map visualization area, area selection and the statistical information panel.</p>
<p>The map visualization provides a geographical representation of the affected areas, employing a color-coded legend for immediate visual differentiation between various categories such as ‘Affected Cropland’, ‘Affected Built-up’, ‘Flooded Areas’, and ‘Affected Building Footprints’. The choice of contrasting colors enhances the readability of the data on a spatial scale.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Load the products we generated var Affected_Builtup = ee.Image('projects/ee-zhengying11140/assets/Affected_Builtup'); var Flooded_Population = ee.Image('projects/ee-zhengying11140/assets/Flooded_Population'); var Flooded_Areas = ee.Image('projects/ee-zhengying11140/assets/Flooded_Areas'); var Classification_Result = ee.Image('projects/ee-zhengying11140/assets/Classification_Result'); var Affected_Cropland = ee.Image('projects/ee-zhengying11140/assets/Affected_Cropland'); var BuildingFootprints = ee.Image('projects/ee-zhengying11140/assets/MaskedClassPrediction');  // Set raster pixels with no value to transparent var Flooded_Areas_Unmasked = Flooded_Areas.unmask(0).selfMask(); var Affected_Cropland_Unmasked = Affected_Cropland.unmask(0).selfMask(); var Affected_Builtup_Unmasked = Affected_Builtup.unmask(0).selfMask(); var BuildingFootprints_Unmasked = BuildingFootprints.unmask(0).selfMask();  // Define visualisation parameters for flooded areas and affected cropland // affected built-up land and affected building footprints var floodedAreasVis = {   palette: ['blue'],   opacity: 0.7 };  var affectedCroplandVis = {   palette: ['yellow'],   opacity: 0.7 };  var affectedBuiltuplandVis = {   palette: ['red'],   opacity: 0.7 };  var affectedBuildingFootprintsVis = {   palette: ['#050509'],   opacity: 0.7 };  // Add layers accordingly Map.addLayer(Flooded_Areas_Unmasked, floodedAreasVis, 'Flooded Areas'); Map.addLayer(Affected_Cropland_Unmasked, affectedCroplandVis, 'Affected Cropland'); Map.addLayer(Affected_Builtup_Unmasked, affectedBuiltuplandVis, 'Affected Built-up'); Map.addLayer(BuildingFootprints_Unmasked, affectedBuildingFootprintsVis, 'Affected Building Footprints');</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>On the top-left of the UI is a tool bar which enables the user to freely select the area they wish to analyse.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Create a drawing tool var drawingTools = Map.drawingTools(); drawingTools.setShown(true);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>On the right side of the map is the statistical information panel, which presents crucial data in a concise, tabulated format. This includes metrics such as affected cropland area (in hectares), affected built-up area, affected population, total flood area, and the total area under consideration. The numerical data is clearly delineated which directly answer the questions examined in this project. If the user want to choose another area, he can click the “clear” button on the bottom of the panel and repeat the process of selecting.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Create a panel to display the statistics and clear button var panel = ui.Panel({   style: {     position: 'bottom-right',     width: '250px',     padding: '8px',     backgroundColor: 'white',     fontFamily: 'Arial',     fontSize: '14px'   } });  // Create a title label var titleLabel = ui.Label({   value: 'Flood Impact Statistics',   style: {fontWeight: 'bold', fontSize: '18px', margin: '10px 0'} });  // Create labels to display the statistics var croplandLabel = ui.Label({style: {color: '#CD8B0E', fontSize: '16px'}}); var buildlandLabel = ui.Label({style: {color: 'red', fontSize: '16px'}}); var populationLabel = ui.Label({style: {color: 'green', fontSize: '16px'}}); var floodAreaLabel = ui.Label({style: {color: '#415FC1', fontSize: '16px'}}); var totalAreaLabel = ui.Label({style: {color: '#243F81', fontSize: '16px'}});  // Create a clear button var clearButton = ui.Button({   label: 'Clear',   style: {backgroundColor: '#FF5722', color: 'black', fontSize: '14px', margin: '10px 0'},   onClick: function() {     drawingTools.layers().reset();     croplandLabel.setValue('');     buildlandLabel.setValue('');     populationLabel.setValue('');     floodAreaLabel.setValue('');     totalAreaLabel.setValue('');   } });  // Add the labels and clear button to the panel panel.add(titleLabel); panel.add(ui.Label('Affected Cropland (ha):')); panel.add(croplandLabel); panel.add(ui.Label('Affected Built-up (ha):')); panel.add(buildlandLabel); panel.add(ui.Label('Affected Population:')); panel.add(populationLabel); panel.add(ui.Label('Flood Area (ha):')); panel.add(floodAreaLabel); panel.add(ui.Label('Total Area (ha):')); panel.add(totalAreaLabel); panel.add(clearButton);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>On the left-bottom is a panel of legend, which represents different color of the land use.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Create a legend panel var legend = ui.Panel({   style: {     position: 'bottom-left',     padding: '8px'   } });  // Create a legend title var legendTitle = ui.Label({   value: 'Legend',   style: {fontWeight: 'bold', fontSize: '18px', margin: '0 0 4px 0'} });  legend.add(legendTitle);  // Create a legend row var makeRow = function(color, name) {   var colorBox = ui.Label({     style: {       backgroundColor: color,       padding: '8px',       margin: '0 0 4px 0'     }   });   var description = ui.Label({     value: name,     style: {margin: '0 0 4px 6px'}   });   return ui.Panel({     widgets: [colorBox, description],     layout: ui.Panel.Layout.Flow('horizontal')   }); };  // Add legend items legend.add(makeRow('yellow', 'Affected Cropland')); legend.add(makeRow('red', 'Affected Built-up')); legend.add(makeRow('#415FC1', 'Flooded Areas')); legend.add(makeRow('#050509', 'Affected Building Footprints'));  // Add the legend to the map Map.add(legend);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="4" type="1">
<li>Data transmission</li>
</ol>
<p>The code loads a series of pre-generated raster images representing different aspects of the flood impact such as ‘Affected Builtup’, ‘Flooded Population’, etc. These rasters are processed to set non-valued pixels to transparent, which would allow for overlaying them on the map without obscuring other layers.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Load the products we generated var Affected_Builtup = ee.Image('projects/ee-zhengying11140/assets/Affected_Builtup'); var Flooded_Population = ee.Image('projects/ee-zhengying11140/assets/Flooded_Population'); var Flooded_Areas = ee.Image('projects/ee-zhengying11140/assets/Flooded_Areas'); var Classification_Result = ee.Image('projects/ee-zhengying11140/assets/Classification_Result'); var Affected_Cropland = ee.Image('projects/ee-zhengying11140/assets/Affected_Cropland'); var BuildingFootprints = ee.Image('projects/ee-zhengying11140/assets/MaskedClassPrediction');</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>When the user selects an area on the map, the onDraw event triggers data capture. Then, a variable aoi is returned, which represents geometry, and this variable is brought into the function calculateFloodImpactStats for calculation. The equations are encapsulated to calculate the full range of values required. When the user needs to calculate new data, just refresh the value of aoi, which is very efficient.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Listen for the draw end event drawingTools.onDraw(function(geometry) {   // Get the drawn geometry   var aoi = geometry;      // Display a calculating message   croplandLabel.setValue('Calculating...');   buildlandLabel.setValue('Calculating...');   populationLabel.setValue('Calculating...');   floodAreaLabel.setValue('Calculating...');   totalAreaLabel.setValue('Calculating...');      // Call the calculation function and update the labels   var stats = calculateFloodImpactStats(Affected_Cropland, Affected_Builtup, Flooded_Population, Flooded_Areas, BuildingFootprints, 'VV', aoi);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>A function calculateFloodImpactStats is defined to compute statistics such as the area of affected cropland and built-up land in hectares, the number of affected population, and the area of flooded regions, based on the pixel values of the respective images within the selected AOI. The calculations use GEE’s reduction methods over the specified region at a defined scale.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">calculateFloodImpactStats</span>(Affected_Cropland<span class="op">,</span> Affected_Builtup<span class="op">,</span> Flooded_Population<span class="op">,</span> Flooded_Areas<span class="op">,</span> BuildingFootprints<span class="op">,</span> polarization<span class="op">,</span> aoi) {   <span class="co">// Calculate the area of each affected cropland pixel   var affectedCroplandArea = Affected_Cropland.multiply(ee.Image.pixelArea());    // Calculate the sum of the affected cropland area   var croplandStats = affectedCroplandArea.reduceRegion({     reducer: ee.Reducer.sum(),     geometry: aoi,     scale: 10,      maxPixels: 1e9   });    var croplandAreaHectares = ee.Number(croplandStats.get('b1')).divide(10000).round();    // Calculate the area of each affected built-up land pixel   var affectedBuildlandArea = Affected_Builtup.multiply(ee.Image.pixelArea());    // Calculate the sum of the affected built-up land area   var buildlandStats = affectedBuildlandArea.reduceRegion({     reducer: ee.Reducer.sum(),     geometry: aoi,     scale: 10,     maxPixels: 1e9   });    var buildlandAreaHectares = ee.Number(buildlandStats.get('b1')).divide(10000).round();    // Calculate the number of affected population   var populationStats = Flooded_Population.reduceRegion({     reducer: ee.Reducer.sum(),     geometry: aoi,     scale: 100,     maxPixels: 1e9   });    var affectedPopulation = ee.Number(populationStats.get('b1')).round();    // Calculate the area of flooded regions   var flood_pixelarea = Flooded_Areas.multiply(ee.Image.pixelArea());    var flood_stats = flood_pixelarea.reduceRegion({     reducer: ee.Reducer.sum(),     geometry: aoi,     scale: 10,     bestEffort: true   });    var flood_area_ha = ee.Number(flood_stats.get('b1')).divide(10000).round();     // Calculate the total area of the selected AOI   var totalArea = ee.Image.pixelArea().reduceRegion({     reducer: ee.Reducer.sum(),     geometry: aoi,     scale: 10,     maxPixels: 1e13   });    var totalAreaHectares = ee.Number(totalArea.get('area')).divide(10000).round();   // Return an object containing all the calculated results   return {     croplandAreaHectares: croplandAreaHectares,     buildlandAreaHectares: buildlandAreaHectares,     affectedPopulation: affectedPopulation,     floodAreaHectares: flood_area_ha,     totalAreaHectares: totalAreaHectares   }; }</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="link" class="level2">
<h2 class="anchored" data-anchor-id="link">Link:</h2>
<p><a href="https://github.com/MengyuanHan1/BigData">Github For the Application</a></p>
<p><a href="https://hanmengyuan826.users.earthengine.app/view/flooddamage">Application</a></p>
<p><a href="https://code.earthengine.google.com/?scriptPath=users%2Fhanmengyuan826%2FGEE%3ASourceCode">Application Source code</a></p>
<p><a href="https://code.earthengine.google.com/?scriptPath=users%2Fhanmengyuan826%2FGEE%3AUI">Application UI code</a></p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'alternate';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>